package Missile
import HashSet

interface CallbackOnHit
    function callback()

public class Missile
    /** Instance variabels, default settings for missiles. */
    real scale = 1.
    real height = 80.
    real speed = 900.
    string trail = ""

    /**
    Creates an missile effect from any model. This effect inherits its position
    from the source.
    */
    static function create(string modelFile, vec3 source, vec2 target) returns Missile
        Missile missile = build(modelFile, source, target.toVec3())
        return missile

    /**
    Creates an missile effect from any model. This effect inherits its position
    from the source.
    */
    static function create(string modelFile, vec3 source, vec3 target) returns Missile
        Missile missile = build(modelFile, source, target)
        return missile

    /**
    Creates an missile effect from any model. This effect inherits its position
    from the source.
    */
    static function create(string modelFile, vec3 source, unit target) returns Missile
        Missile missile = build(modelFile, source, target.getPos3Fly())
        return missile
    
    function setScale(real scale)
        art.setScale(scale)
        this.scale = scale
    
    function setHeight(real height)
        this.height = height

    function setSpeed(real speed)
        this.speed = speed

    function setTrail(string trail)
        this.trail = trail

    function onHit(CallbackOnHit cb)
        this.cb = cb

    /** Internal. Instance variabels. */
    private effect art
    private vec3 pos
    private vec3 v
    private unit u
    private CallbackOnHit cb

    /** Internal. A HashSet containing all missiles. */
    private static let missileSet = new HashSet<Missile>

    /** Internal. Build a new missile and set its target. */
    private static function build(string modelFile, vec3 source, vec3 target) returns Missile
        let missile = new Missile()
        missile.art = addEffect(modelFile, source.add(0., 0., missile.height))
        missile.pos = source
        missile.v = target
        missileSet.add(missile)
        if missileSet.size() == 1
            clock.startPeriodic(ANIMATION_PERIOD, function tick)

        return missile

    /** Internal. A timer that is used to move all missiles. */
    private static let clock = CreateTimer()

    /** Internal. Move the missile to the target position */
    private static function tick()
        for missile from missileSet.iterator()
            vec3 source = missile.art.getPos3()
            vec3 target
            vec3 flyingHeight = vec3(0., 0., missile.height)
            
            if missile.u != null
                target = flyingHeight.op_plus(missile.u.getPos3Fly())
            else if missile.v != ZERO3
                target = flyingHeight.op_plus(missile.v)
            else
                target = source

            if missile.trail != ""
                addEffect(missile.trail, source.op_minus(flyingHeight))..setScale(missile.scale)..destr()

            if source.distanceTo(target) <= missile.speed * ANIMATION_PERIOD
                missile.art.destr()
                missile.cb.callback()
                missileSet.remove(missile)
                destroy missile
            else
                missile.art
                    ..setPos(source.moveTowards(target, missile.speed * ANIMATION_PERIOD))
                    ..setYaw(Atan2(source.z - target.z, source.toVec2().distanceTo(target.toVec2())).asAngleRadians())
                    ..setRoll(Atan2(target.y - source.y, target.x - source.x).asAngleRadians())

        if missileSet.size() == 0
            clock.pause()